Тема : Абстрактные базовые классы 

Наследование позволяет нам абстрагироватся от конкретного типа данных создавая указатель на базовый класс которому присваивается адрес обьекта производного типа через указатель на базовый класс можно вызывать только те методы которые обьявлены в базовом классе производние классы могут переопределять поведение методов базового класса Но бывают ситуации когда в базовом классе должен быть обьвлен обьявлен метод но мы не можем ево реализовать изза того что недостаточно данных(информации) Обьявлять ево в базовом классе нужно для того чтобы ево можна было вызвать при обстрагировании такие мотоды называются чистыми виртуальными функциями и абстрактными методами 

======== Пример ========
class Account 
{
public:
 virtual double Withdraw(double account ) = 0;
 virtual double Topup(double account ) = 0;
}
======== Конец  ========
Производные классы обязаны переопределить чистые вируальные функции задав им реализацию таким образом базовый класс обьвляет интерфейс который обязаны реализовать все производные классы таким образ работая через указатель на базовый класс есть гарантия что методы будут реализованы 
Класс который имеет хотябы одну абстрактную функцию называют абстрактным и обьект такого класса создавать нельзя 
Если производный класс не переопределит все чистые виртуальные функции то он тоже станет абстрактным 
-Конструкторы виртуальными быть не могут-

Тема : Вируальный диструктор

Кострукторы виртуальными быть не могут так как при создании обьекта класса мы всегда указываем конкретный тип данных а следовательно указываем какой конструктор мы вызываем 
А диструкторы виртуальными быть могут так как при удален инии обьекта через указатель на базовый класс по умолчанию будет вызываться деструктор базового класса потому что для них тоже используется ранее связываение по умолчанию и чтобы при удалении через абстракцию вызывался нужный диструктор они должны использовать механизм позднего связывания 
Так же диструкторы могут быть чисто виртуальными но им всеравно нужно предоставлять тело потому что при удалении обьекта производного класса всегда вызывается диструктор базового класса тоже 

======== Пример ========
class Account 
{
public:
 virtual double Withdraw(double account ) = 0;
 virtual double Topup(double account ) = 0;
 virtual ~Account() = 0 {};
}
======== Конец  ========

Бинарный может создавать свои типы расширения + шифрует
(если открыть не через программу будет показывать не правильные данные)
char целочислинный тип данных (char = 1 байт)
для бинарной работы используется указатель на char

fwigth <- принимает указатель на буфер што нужно записать в файл 
fwrite(что передаем , размер {sizeof(int)},сколько переменных записываем, куда записываем)

fread <- считываем информацию
fread(куда считать, размер , сколько переменных , откуда считываем)

чтобы функция принимала нужно const char* имя

Бинарный может создавать свои типы расширения + шифрует
(если открыть не через программу будет показывать не правильные данные)
char целочислинный тип данных (char = 1 байт)
для бинарной работы используется указатель на char

fwigth <- принимает указатель на буфер што нужно записать в файл 
fwrite(что передаем , размер {sizeof(int)},сколько переменных записываем, куда записываем)

fread <- считываем информацию
fread(куда считать, размер , сколько переменных , откуда считываем)

чтобы функция принимала нужно const char* имя

======== Продолжение 2 ========

Тема : Парадигма ООП 

ООП - подход к разработке приложения при котором предметная область представляется в виде набора сущностей
со своими характиристиками и повидением
каждая такая сущность описывается с помощью класов 
=================================
ТОЕСТЬ в ооп всё есть обьект 

ооп строится на 3(4) принципах которые еще називают китами ооп
1.Абстрагирование - умение выделить только нужные характиристики и повидение и отбросить не нужное
2.Инкапсуляция - обьеденение характеристик и повидения обьекта в одно целое а так же возможность скрытия внутриней реализации класа и предоставление открытого интерфейса для работы с ним
3.Наследование - возможность создания нового класа на основе уже существующего етот новый клас наследует характеристики и повидения своего родительского класа а так же может расширять добавляя новые возможности
4.Полимерфизм - один интерфейс множественая реализация

Тема : Классы

Класс - Пользовательский тип данных который описывает некоторые обьекты в предметной области характеристики етого обьекта описываются с помощью переменных членов класса также называемых полями класа а повидение описывается с помощью функций члена класса также называемых методами класса

class name 
{
  поля и методы
}

class Point
{
public;
int x;// поле класса
int y;
void Print() // метод класса
{
	cout << x << y;
}
}

язык с++ позволяет определить метод как внутри так и вне класса

class Point
{
public:
	int x = 1;// поле класса
	int y = 2;
	void Print(); // Обьявление метода
};

void Point::Print() // Определение метода(Обязательно указать имя класса(Point))
{
	cout << x << y;
}
Фото 04_1

Класс только описание типа данных для того чтобы создать обьект (екземпляр) класса нужно обьявить переменную 
а для доступа к методу или полю класса через обьект используется оператор точка{.}(также как и в структурах)

Point p1;
p1.x = 0;
p1.y = 0;
p1.Print();

Важно понимать что метод можна вызвать только для обьекта класса 
Print();// вызовет ошибку

Рекоминдация использовать именна полей класса создавать с использованием специальных суфиксов или префиксов типа x_ 
часто создают с помощью префикса m_x, m_y либо используют суфикс x_ всё зависит от кодинг стайла 

Тема : Инкапсуляция 
Инкапсуляция - обьеденение характеристик и повидения обьекта в одно целое а так же возможность скрытия внутриней реализации класа и предоставление открытого интерфейса для работы с ним. Поля хранят состояние обьекта а методы обращаются к етому состоянию и позволяют ево менять когда всё состояние обьекта открыто ето позволят несанкцанировано ево изменить. Инкапсуляция позволяет также защитить наш клас от несанцианированых изменений ето делается в с++ спомощью спецификтора доступа их три public , protect, private

pablic - позволяет обьявить члены класса к которым можно получить доступ из вне етого класса
private - позволяет обьявить члены класса доступ к которым можно получить только из методов етого же класса
protect - окрывает доступ члены класса только методом етого же класса или дочернего(при наследовании класса)

Продолжение файла 04
=====================================================
Accessers - функции доступа (дают доступ к полям)
поля класа чаще всего реализуются приватно для того чтобы избежать несанкцианированого доступа
но для того что-бы установить или получить из них значение реализуются открытые методы которые називаются методами аксесорами(Accessers)
методы которые позволяют устанавливать значение в поле класа называются модефикаторы и обычно именуются с префиксом Set(Set_hours)
Методы которые позволяют получить значение полей класса называются инспекторами и обычно именнуются с префиксом Get (Get_hours)
в модификаторы не следует делать ввод с чего либо(клавиатуры или других источников) так как при разроботке класа мы не знаем зарание откуда будут поступать данные а делать методы на все случаи жизни ето плохой архитектурный подход лучше всего чтоб метод модификатор принимал значение в виде параметров

Тема : Конструкторы 

Конструкторы - ето специальние методы класса которые вызиваются автоматически при создании обьекта их задача инициализировать поля класса начальными значениями 
Имя конструктора всегда совпадает с именем класса и конструктор не имеет возвращаемого типа данных
Конструкторы могут быть перегружеными (у класса может быть несколько конструкторов с разным списком параметров конструкктор без параметров называют конструктором по умочланию )

//так обьявляются 
Time Time1(); 
Time Time2(int hours,int minutes,int seconds);
Time Time3(int hours,int minutes);
Time Time4(int hours);
//так вводятся
Time Time1(); // Defold
Time Time2(12 , 33 , 50 );
Time Time3(12 , 33);
Time Time4(12);

Так как при создании обьекта класса всегда должен вызиватся конструктор компилятор генирирует конструктор по умолчанию если в класе не обьявлен ни один конструктор
Тоесть если обьявить в классе хоть один конструктор с параметрами то компилятор не создаст конструктор по умолчанию и при создании обьекта нужно будет передавать аргументы для инициализации
Технически конструктор можно создавать с любым индитификатором доступа но если обьявить конструктор закрытым или защищённым то создать обьект вне класса с помощью етого конструктора будет нельзя 

Тема : Инициализаторы 

Инициализаторы - кострукция которая позволяет задать начальное значение полю класса до вызова конструктора 
Инициализаторы необходимо использовать в тех ситуациях когда поле класса должно быть проинициализировано при создании например если полем класса является константа ,сылка или обьект класса у которого нет конструктора по умолчанию а так же инициализаторы используются при наследовании если у базового класса нет конструктора по умолчанию
Синтаксис инициализаторов 
Constructor[] : initialization
{
}

Когда полем класса является константа 

public:
&() : a(10) {
};
private : 
const int a

B(int& i) : b(i) {
}

class C
{
D(int i ) {.....}
}

class D

D() : d(10) {
 ....
}

Инициализаторы могут использоваться также для инициализации любых полей класса 

можно зделать так же Time:: Time(): hours(0)
{
} 

начиная с с++ v11 инициализации членов класса можно зделать с помощью операции = 
Делегирование конструктора - ето возможность появилась начиная с с++ v11

Делегирование конструктора позволяет из одного конструктора класса вызвать другой конструктор того же самого класса , делигирование используется для того чтобы избежать дублирования кода инциализации

Time(int hours,int minutes,int second) {...}
Time (int hours,int minutes : Time (hourdse,minutes,0){}

продолжение 07
=========================================================
Диструктор - специальный метод класса который вызывается автоматически при удалении обьекта
Цель диструктора - очистить ресурсы которые выделяет обьект такие как динамическая память ,файл ,соеденение по сети и т.д.
Имя диструктора всегда совпадает с именем пласса перед которым ставится знак ~ 
дИСТРУКТОР У КЛАССА МОЖЕТ БЫТЬ ТОЛЬКО ОДИН НО ОН НИКОГДА НЕ ПРИНИМАЕТ ПАРАМЕТРЫ	//зделать маленькими буквами
так ка диструктор должен вызываться при уничтожении обьекта класса в классе вегда должен быть диструктор и если програмист не предоставляет свой диструктор то компилятор создает ево автоматически

Синтаксис диструктора :
~Distrukt()
{
  код освобождение рисурсов
}

Тема : Ключевые слова default и delete

начиная с языка с++ v11 появились ключевые слова default , delete

delete - позволяет указать компилятору что он не должен предоставлять какойто метод автоматически

------------------------------------------------------
ПРИМЕР

class A
{
public:
 A() = delete;
 ~A() = delete;
}
------------------------------------------------------

default - указывает компилятор реалезовать какойто метод по умолчанию

------------------------------------------------------
ПРИМЕР

class B
{
public:
 B() = default;
 ~B() = default;
}
------------------------------------------------------

defauld , delete можно использовать только со специальными методами класа (с теми методами которые компилятор предоставляет автоматически)

Ключевое слово This - указатель содержащий адресс обьекта для которого вызван не статический елемент класса
Доступно только для не статических елементов класса
This Не явно используется при обращении к полям класса для того что-бы компилятор понимал с полями какого обьекта работает метод (также к This можно обращатся явно)

------------------------------------------------------
ПРИМЕР

int Tume::Get_hour()
{
 return this->hours_;
}
------------------------------------------------------

Тема : Конструктор копирования 

Конструктор копирования - специальный вид конструктора цель которого реализовать алгоритм копирования одного обьекта в другой 
вызывается не явно в 3 ситуациях 
1. Создание нового обьекта на основе уже сущестующего.
A obj1;
A obj2  = obj1;

2. При передаче обьекта в функцию по значению
void fune(A obj){...};
A obj1;
fune(obj1);

3.Когда фунция возваращает обьект по значению
A fune () {A obj,return obj}
A a = func();

4.Но конструктор копирования не вызывается при присваивании одного сущестующего обьекта в другой сущестующий обьект 

A obj1;
A obj2;
obj2 = obj1;

В етой ситуации вызывается перегрузка оператора присваивания

Продолжение 09
==========================================
Конструктор копирования также предоставляется компилятором автоматически если програмист ево не обьявил в класе тогда конструктор копирования выполняет побитовое копирование
Если обьекты класса содержат лиш простые поля то можно не реализовывать свой собственый конструктор вполне достаточно того что компилятор предостваляет автоматически 
Но если класс содержит указатель на какой либо ресурс (например динамическую память) то при побитовом копировании скопируется лиш адрес ресурса а не сам ресурс (Так же называется поверхностное копирование) такая ситуация может привести к проблемме битого указателя например при удалении одной из копий удалится так же ресурсна которы сылается указатель а во второй копии указатель станет битый для решения етой проблеммы нужно реализовать глубокое копирование тоесть копироване самого ресурса а не ево адреса 

Костратные методы обьект класса можно создать константным указав что етот обьет менять нельзя в етом случае компилятору нужно понимать какие методы не меняют состояние обьекта и их можно вызвать для константного обьекта тоже самое относится к константной сылке на обьект и указателю на костантый обьект 

	Продолжение 11
#pragma redion coment
code
#pragma endredion

Тема: Перегрузка операций
В языке с++ операции реализованы в виде функций

	Пример 
======================================
int a = 5 ;
int b = 6 ;
cout << a + b << endl;
// cout << operator+(a,b) << endl;
======================================

Так как функции поддерживают механизм перегрузки то мы можем определить собственую версию операции для работы со своими типами данных
Перегрузка операций выполняется с помощью определения функции или метода класса со специальныим именем

operator знак
// cout << operator+(a,b) << endl;

Синтаксис перегрузки операций 
тип operator знак ( параметры )
{
блок кода
}

При перегрузке операций есть ограничения 
*можно прегрузить только существующие операции ( нельзя придумывать собственые операции )
*изначальное количество операндов, поддерживаемых оператором, изменить невозможно ( преоритет и асициативность операций )
Нельзя прегрузить операцию для стандартных типов данных ( хотя бы один из операндов должен быть пользовательского типа )

Также существуют операции которые нельзя перегрузить 

*Тернарные операции (?:)
*Оператор sizeof
*оператор разрешения области видимости (::)
*оператор разбора члена (.)
*Указатель как оператор выбора члена (.*)

Большенство операций можно перегрузить 2 способами глобальной функцией или методом класса 
Но есть ряд операций которые перегружаются только методом класса 

*Оператор присваивания =
*Оператор визова функции ()
*Оператор индексации []
*Выбор члена класса через указатель ->
*Оператор delete
*Оператор new
*Оператор приведения типа () 

Так же существуют ситуации при которой операцию можно перегрузить только глобальной функцией
Если левый операнд бинарной операции является обьектом не вашего типа данных то перегрузить операцию методом невозможно так как метод всегда вызывается для левого операнда

При перегрузке бинарных операций в виде глобальной функции они должны принимать 2 параметра левый и правый операнд
тип operator знак ( тип leftbp,тип rightbp )
а при перегрузке методом левый операнд передается неявно как this а правый операнд передается как единственый параметр
тип operator знак ( тип rightbp )

При реализации унарных операций в случае глобальной функции принимается 1 параметр который является операндом операции
тип operator знак ( тип operator )
в случае метода единствений операнд принимается как this и метод не имеет параметров
тип operator знак ()

Перегрузка инкримента дикримента 
Так как инкримент и дикримент имеют 2 формы префиксную и постфисную то каждую операцию нужно реализовывать в 2 вариантах
Префиксный вариант должен изменять свой операнд и возвращать модифицированый вариант 
Постфиксный вариант должен изменять свой операнд но возвращать первоначальное значение для того чтобы при пергрузке операций различались форми префксная и постфиксная для постфиксных форм передается фиктивный параметр типа int 

Пример перегрузки в виде функций 
Fraction operator++( Fration& fr );
Fraction operator++( Fration& fr, int );

Пример в виде методов 
Fraction operator--();
Fraction operator--( int );

Перегрузка преобразования типов 

При перегрузке следует отличать перегрузку из другого типа данных в наш и перегрузку из нашего типа данных в другой они реализуются разными способами 
если мы хотим зделать преобразования из другого типа в наш то нужно реализовать конструктор с 1 параметром который будет принимать преобразуемое значение
например при ситуации 
int a = 4;
Fraction fr4 = a;//Fraction(a)

Такое приобразование может использоваться как явно так и не явно
не явное преобразование могут привести к неожиданому поведению преобразование будет вызываться там где вы ево не ожидаете поетому лучше избегать такого поведения обьявив конструктор спомощью ключевого слова exprisit
extpisit Fraction(int numerator);

Ключевое слово extpisit указывает что преобразование может ипользоваться только явное 

=========Продолжение 18 =========

Приобразование из нашего типа данных в другой осуществляется с помощью перегрузки оператора преобразования 
operator тип ()
{

}

Тип возвращаемого значения не указывается так как указан тип в который нужно преобразовать преобразование типов всегда реализуется методом класса 
Перед операторами преобразования так же  можно указывать ключевое слово explicit 

Перегрузка оператора присваивание оператор присваивания вызывается в ситуации когда один существующий обьект класса приваивается другому уже существующему обьектн класса 

A a;
A b;
a = b;

При етом обычно проиходит копирование данных из правого операнда в левый
Оператор присваивания всегда реализуется как метод класса. При реализации оператора присваивания нужно выполнить следующие правила 

1.Выполнить проверку на само присваивания ( технически обьект можно  присвоить сам себе и ето может привести к ошибке ) 
2.Перед копированием данные левого операнда нужно очистить 
3.Оператор присваивания возвращает сылку на левый операнд для того чтобы можно было использовать ево в выражениях

DynaciArray& DynaciArray::operator= (const DynaciArray& sourceObj)
{
  if(this != &sourceObj)//проверка на сомприсваивание
  {
    Clear();
    Copy(sourceObj);
  }
  
  return *this;
}

Оператор индексация 

Оператор индексации перегружается всегда как метод класса и чаще всего используется для поиска елемента в составном обьекте 

тип operator[] (параметр)
{

}

если оператор индексации возвращает результат по значению то ево можна будет ипользовать только справа от знака = 
для того чтобы оператор индексации можна было использовать слева от знака = он должен делать возврат по сылке (часто реализуют две версии оператора индексации одну константную версию которая будет ипользоваться только справа от знак = ,другую не константную которая делает возврат по сылке )
например
int operator[](size_t index) const;
int& operator[](size_t index) ;

============= Продолжение 22 =============

Рекомендации Берн Струпструнга
*Если операции возвращают новый обьект не меняя состояние операндов то ее лучше реализовывать в глобальных функциях
*Если операция меняет состояние своево операнда то ее лучше реализовывать методом

Семантика переноса

существуют ситуации при которых копирование обьекта владеющего большим ресурсом неоправданно например при возврате из функций так как обьект который возвращается из функций будет всеравно удалён то нет смысла тратить время на ево копирование можно просто передать права владения ресурсом другому обьекту 
для того чтобы компилятор мог различать ситуации в которых нужно делать копирование от ситуаций в которых нужно делать перенос в язык с++ версии 11 добавили новый вид сылок которие называются r-value сылки , силки которые существовали до с++ версии 11 начали называть l-value.
l-value сылку можно создать только для значения адрес которого мы можем получить в коде (например переменные или константы) 
r-value силки мы можем создать для значений адрес которых мы не можем получать (литералов, временных обьектов которые создаются при возврате из функций и операций)
int&& p1 = 123;
int&& p2 = foo();
int&& p3 = 2 + 3;

благодаря появлению r-value силок в класе стало возможно реализовать не только симантику копирования но и симантику переноса она реализуется с помощью конструктора и оператора присваивания которые принимают r-value сылки . 
//constructor move
DynamicArray(DynamicArray&& sourceObj);
//operator move
DynamicArray& operator=(DynamicArray&& sourceObj);

Теперь компилятор может опредилять в каких ситуациях нужно призывать копирование а в каких перенос например если в обьект будет присваиваться результат выполнения некоторой функции то компилятор вызовет симантику переноса потомучто результатом функции является временный r-value обьект.
Так же перенос можно вызвать явно используя фунцию move() из стандартной библиотеки 

Дружествиные функции и классы 

Класс может открывать детали своей реализации для функций и класса которые не являются ево членами ето делается спомощью ключевого слова friend 
для того чтобы обьявить другом внешнюю функцию внутри класса нужно обьявить ево прототип с ключевым словом friend при етом спецыфиктори доступа ника не влияют на дружествыние  функции так как они не являются членами класса 
friend Fraction operato*(Fraction leftOp, Fraction rightOp);
friend Fraction operato*(Fraction leftOp, int rightOp);
friend Fraction operato*(int leftOp, Fraction rightOp);

Обьявить другом можно не только функцию но и целый класс 

======== Продолжение 23 ========

Статические поля 

Обычные поля класа называются екземплярными полямий потому что создаются для каждого екземпляра класа но также в класе можно обьявлять поля со спецификатором static они относятся к статическому класу памяти тоесть их время жизни определяется временем жизни приложения такие поля создаются один раз для всего класса и удаляются при выходе приложения 

class TestClass
{
public:
int field1;
int field2;

static int staticField; //обьявление
};

//Определение
int TestClass::staticField;

_____Статические поля обязательно нужно определять в глобайльной области видимости_____
Обращатся к статическим полям можно через имя класса или через обьект
имя класса TestClass::staticField
через обьект obj1.staticField
Но с точки зрения читаемости лучше использовать 1 вариант

Спецификторы доступа влияют на видимость статических полей 

Статические методы
Методы класса тоже делятся на еземплярные и статические
Екземплярные методы класса могут вызываться только для обьекта класса они получают адрес етого обьекта в указатель this и могут работать с екземпляраными полями обьекта 
Статические методы класса могут вызываться через имя обьекта и имя класса , они никогда не получают адрес обьекта для которого вызваны следовательно внутри такого метода нет указателя this и нельзя обращатся к екземплярным полям 

======== Продолжение 25 ========

Тема: Шаблоны

Шаблон - заготовка на основе которой компилятор создаёт функцию или класс 
Шаблоны используются для описания алгоритмов которые отличаются своим типом данных переменных
Шаблон функции - ето возможность создать образец фунции без указания конкретного типа данных 
например 

----------------------
tmplate<typename T>
void mySwap(T&a, T&b )
{
T tmp = a;
a = b;
b = tmp;
}
----------------------

Шаблон ето еще не функция (заготовка для ее создания )
сама функция будет создаватся на основе шаблона когда компилято встретит вызов функции с аргументами конкретного типа данных

пример
----------------------
int a = 5 b = 7;
mySwap(a,b)
----------------------

когда компилятор встречает вызов функции он вначале ищет перегрузку фунции со списком параметров которые соотвецтвуют списку аргументов если не находит то ищет шаблон на основе которого может создать такую функцию 
Процес создания функции на основе шаблона називается инстанцирование а такая функция называется специализацией шаблона  
Инстанцирование происходит только первый раз при обращении к нему с определенным типом данных если же етот тип данных используется второй раз то компилятор будет вызывать готовую специализацию шаблона 

шаблоны могут иметь несколько параметров типов 
пример
----------------------
template<typename T1,typename T2>
T2 sum (T1 num1 ,T2 num2 )
----------------------

Если шаблонная функция использует несколько параметров типов и переменные разных типов данных будут использоваться в одно выражении то необходимо вычислять тип етого приложения так-как типы данных зарание неизвестны
до с++ 11 не было возоможности вычеслить тип выражения а начиная с с++ 11 появился оператор decltype который позволяет ето зделать 
синтаксис использования ево с шаблоными функциями для вычестления возвращаемого типа менялся в разных версиях с++

c++ 11
tmplate <typename T1 , typename T2 >
auto sum (T1 num1, T2 num2 ) -> decltype (num1 + num2 )
{
......
}

c++ 14
tmplate <typename T1 , typename T2 >
decltype(auto) sum (T1 num1, T2 num2 )
{
......
}

c++ 17
tmplate <typename T1 , typename T2 >
auto sum (T1 num1, T2 num2 )
{
......
}

======== Продолжение 29 ========

Тема : Шаблоны классов

Шаблоный класс - образец по которому компилятор будет создавать версию класса работающего с конкретными типами данных 

пример
----------------------
template<typename T>
class A
{
public:
 void setField(T value)
 {
 field = value;
 }
 T GetField()
 {
 return field;
 }
private:
 T field;
};
----------------------

Параметр типа можно использовать для обьявления полей класса ,параметров методов ,возвращаемого типа данных , переменных
При создании обьекта класса неопходимо указать конкретный тип данных который будет поставлятся на место параметра типа

пример
----------------------
A<int> obj1;
A<double> obj2;
A<char*> obj3;
----------------------

У шаблонного класса все методы являются шаблонами поетому когда методы выносятся за приделы класса они так же описываются как шаблоны функции

пример
----------------------
template<typename T>
class A
{
public:
 void setField(T value)
 {
 field = value;
 }
 T GetField()
 {
 return field;
 }
private:
 T field;
};

template<typename T>
void A<T>::SetField(T value)
{
fiedl = value
}
----------------------

Реализацию методов шаблоного класса нельзя вынасить в отдельный cpp файл так как компиляция cpp файлов выполняется раздельно 
обычно обьявления методов и их реализация записываетсяв header файл 

С шаблонами классов так же можно выполнять явную и частичную специализацию 

пример 
----------------------
template<typename T>
class A
A()
~A()

void SetField(const char* value)

char* GetField()

private:
 char* field = nullptr;
};
----------------------

пример 
----------------------
template<typename T1, typename T2>
Class B
{
public:
T1 field;
T2 field;

void SetField(T2 value);
};

template<typename T1>
Class B<T1 , char*>
{
public:
T1 field1;
char* field2;

void SetField(char* value);
};
----------------------

